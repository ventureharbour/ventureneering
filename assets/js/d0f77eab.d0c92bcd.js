"use strict";(self.webpackChunkVentureneering=self.webpackChunkVentureneering||[]).push([[1865],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=p(n),h=r,d=m["".concat(l,".").concat(h)]||m[h]||c[h]||o;return n?a.createElement(d,i(i({ref:t},u),{},{components:n})):a.createElement(d,i({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1347:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return p},assets:function(){return u},toc:function(){return c},default:function(){return h}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],s={authors:"sudo-jaa",title:"\ud83d\udc7eTaming Type Inferenece",description:"as const assertions",slug:"taming-type-inference",tags:["Typescript","Programming","Types","Type Inference"]},l=void 0,p={permalink:"/blog/taming-type-inference",source:"@site/blog/2022-04-04-the-unreasonable-power-of-const-assertions.mdx",title:"\ud83d\udc7eTaming Type Inferenece",description:"as const assertions",date:"2022-04-04T00:00:00.000Z",formattedDate:"April 4, 2022",tags:[{label:"Typescript",permalink:"/blog/tags/typescript"},{label:"Programming",permalink:"/blog/tags/programming"},{label:"Types",permalink:"/blog/tags/types"},{label:"Type Inference",permalink:"/blog/tags/type-inference"}],readingTime:7.975,truncated:!0,authors:[{name:"James",title:"Engineer @ Venture Harbour",url:"https://github.com/sudo-jaa",imageURL:"https://github.com/sudo-jaa.png",key:"sudo-jaa"}],frontMatter:{authors:"sudo-jaa",title:"\ud83d\udc7eTaming Type Inferenece",description:"as const assertions",slug:"taming-type-inference",tags:["Typescript","Programming","Types","Type Inference"]},nextItem:{title:"\ud83d\udd78 Top 5 social media regex for web developers 2022",permalink:"/blog/top-5-social-media-regex-for-web-developers-2022"}},u={authorsImageUrls:[void 0]},c=[],m={toc:c};function h(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"We've all been there.")," The same problem for three days now. You've exhausted every developer in your team with your incessant quacking; there's no amount of rubber ducking that can help you. No matter who looks at it,\nno matter their level of experience, no matter what phase-4 superpowers they might wield against the program, it does not make sense. You take a walk, eat some fruit, listen to that one banger that Iceland put out for the cancelled eurovision,\nneck ",(0,o.kt)("em",{parentName:"p"},"another")," coffee, and get back to frustrating your entire team with the endless clack-clack-clacking of your blue-switch keyboard.\nYou think you might have finally figured it out. Your eyes light up with relief measured in days. The build hasn't failed twenty seconds in this time. It's happening. It's really happening."),(0,o.kt)("p",null,"Nope. Just kidding.\nAnother type error."),(0,o.kt)("p",null,"If you've ever worked with Typescript, this is likely to have been your reality at some point or another. Especially if you have recently migrated from Typescript's more dynamic sibling: Javascript. For some reason you can't explain, you end up programming into the early hours. It's at times like this that\nthe horror novel you've been reading begins to seep into your reality. You somehow come to know that you are the hapless acolyte chanting into the void with naught but a sage candle,\nand the Typescript compiler is some mighty Elder God whose machinations are unknowable to mere mortals such as yourself."),(0,o.kt)("p",null,"Let's break down some compiler behaviour, take a deep dive into general (wide) type inference, how we can explicitly tell the compiler to instead infer narrow types, and how we can use this to our advantage."),(0,o.kt)("p",null,"Typescript is always going to try to infer a type from your variables. If you've done a good job keeping things typed so far, this will usually be really helpful in keeping track of the data you're operating on.\nIf there's some instance of an ",(0,o.kt)("inlineCode",{parentName:"p"},"any")," variable in the data leading to the function you're working on now, then you might start to get a little burned by your own hubris. The worst case scenario is that everything is ",(0,o.kt)("inlineCode",{parentName:"p"},"any"),", and you are just writing javascript with extra\nsteps for some unfathomable reason.\nBut what about if i'm defining new variables from scracth that don't depend on any other data. Surely Typescript will always get it right and keep me covered, right?"),(0,o.kt)("p",null,"...Right? "),(0,o.kt)("p",null,"Let's look at some examples. Starting with the humble ",(0,o.kt)("inlineCode",{parentName:"p"},"Array"),". "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const arr = [];\n\narr.push(1);\narr.push("hello");\n')),(0,o.kt)("p",null,"This is, annoyingly, valid Typescript. You can log this out and get ",(0,o.kt)("inlineCode",{parentName:"p"},"[ 1, 'hello' ]"),". The reason this works is because at the point our ",(0,o.kt)("inlineCode",{parentName:"p"},"arr")," variable is declared, Typescript does not know what our array ",(0,o.kt)("em",{parentName:"p"},"contains"),". The type of ",(0,o.kt)("inlineCode",{parentName:"p"},"arr")," is ",(0,o.kt)("em",{parentName:"p"},"inferred")," as\n",(0,o.kt)("inlineCode",{parentName:"p"},"any[]"),". It is an array that can contain any data or object. Typescript is dropping type information for items inside. We can push anything we want. "),(0,o.kt)("p",null,"There are two remedies for this frighteningly dynamic behaviour: explicitly writing the type in the variable definition, or providing the array with some data at the point of declaration. "),(0,o.kt)("p",null,"If we now write our program as follows: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const arr: string[] = [];\n\narr.push(1);\narr.push("hello");\n')),(0,o.kt)("p",null,"We get the following error:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.\n\n3 arr.push(1);\n           ~\n")),(0,o.kt)("p",null,"We cannot push a number to an array of strings. At the point of declaration, ",(0,o.kt)("inlineCode",{parentName:"p"},"arr")," is of type ",(0,o.kt)("inlineCode",{parentName:"p"},"string[]"),"."),(0,o.kt)("p",null,"We can achieve the same effect by allowing typescript to infer this type from the initial declaration, like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const arr = [1];\n\narr.push(1);\narr.push("hello");\n')),(0,o.kt)("p",null,"The compiler now fails for a similar reason:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.\n\n4 arr.push(\"hello\");\n")),(0,o.kt)("p",null,"Our ",(0,o.kt)("inlineCode",{parentName:"p"},"arr")," variable is declared with the type ",(0,o.kt)("inlineCode",{parentName:"p"},"number[]")," based on the initial data we passed in."),(0,o.kt)("p",null,"Type inference is great if you're careful. Generally speaking though it is always a safer bet to explicitly type your data if there is any doubt about the integraity of the data going into the declaration. An inferred type cannot protect you against mistakes\nbecause the compiler does not know your intention. Take the following example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const a = 1;\nconst b = "2";\nconst c = 3;\n\nconst arrayOfNumbers = [a, b, c];\n')),(0,o.kt)("p",null,"This code compiles just fine! And although you think your array can only contain numbers, a mistake has defined this type as ",(0,o.kt)("inlineCode",{parentName:"p"},"(string | number)[]"),", meaning you are now able to unwittingly push strings to your array. This will absolutely cause you\nunrecoverable heartache in the near future, as you weigh the heft of this silly mistake some point down the line.\nIf you had explicitly typed your array to begin with, then this issue is completely nullified for the rest of time:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const a = 1;\nconst b = "2";\nconst c = 3;\n\nconst arrayOfNumbers: number[] = [a, b, c];\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"error TS2322: Type 'string' is not assignable to type 'number'.\n\n5 const arrayOfNumbers: number[] = [a, b, c];\n                                       ~\n")),(0,o.kt)("p",null,"You will never again be able to push strings to your array of numbers."),(0,o.kt)("p",null,"So now we know how type inference behaves. Let's look at a hidden pitfall. "),(0,o.kt)("p",null,"Take a look at this array declaration:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const arr = [1, 2];\n")),(0,o.kt)("p",null,"What is the type of ",(0,o.kt)("inlineCode",{parentName:"p"},"arr"),"? Has typescript decided that this is an array of numbers, or a two-item array of numbers. There is a subtle difference between these two types of data. "),(0,o.kt)("p",null,"It turns out Typescript will infer the most general possible type for an inferred-type variable. ",(0,o.kt)("inlineCode",{parentName:"p"},"arr")," above is an array of numbers: ",(0,o.kt)("inlineCode",{parentName:"p"},"number[]"),". This means the compiler is expecting the data contained in ",(0,o.kt)("inlineCode",{parentName:"p"},"arr")," to be a variable length array of numbers that\nwe might push to, pop from, and slice up. Typescript is ",(0,o.kt)("em",{parentName:"p"},"not")," expecting this variable, despite it's initial value, to remain as a fixed two-item tuple. "),(0,o.kt)("p",null,"This holds a few implications. Importantly, we cannot spread our ",(0,o.kt)("inlineCode",{parentName:"p"},"arr")," variable to two specific values that can be used in a function. "),(0,o.kt)("p",null,"The following is not a valid program:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const arr = [1, 2];\n\nconst sum = (valueA: number, valueB: number) => {\n  return valueA + valueB\n}\n\nconsole.log(sum(...arr))\n")),(0,o.kt)("p",null,"Despite the fact that our ",(0,o.kt)("inlineCode",{parentName:"p"},"arr")," variable is an array of two numbers, Typescript cannot guarantee this so it is rejected by the compiler:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"error TS2556: A spread argument must either have a tuple type or be passed to a rest parameter.\n\n7 console.log(sum(...arr))\n                  ~~~~~~\n")),(0,o.kt)("p",null,"This is invalid because, as discussed before, Typescript will always infer the most general type that is assignable to your data. ",(0,o.kt)("inlineCode",{parentName:"p"},"number[]")," is more general than ",(0,o.kt)("inlineCode",{parentName:"p"},"[number, number]"),", and so the former is used, even if the latter is technically correct. "),(0,o.kt)("p",null,"You can solve this one of two ways: you can either type the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"arr")," explicitly, or you can use a feature introduced in Typescript ",(0,o.kt)("inlineCode",{parentName:"p"},"3.4"),": ",(0,o.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions"},"const assertions"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"What the heck is a const assertion?")),(0,o.kt)("p",null,"Simply put - a const assertion tells the compiler that this data should be inferred to the narrowest possible type it is possible to give this data, and make it readonly for good measure. "),(0,o.kt)("p",null,"It looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const arr = [1, 2] as const;\n\nconst sum = (valueA: number, valueB: number) => {\n  return valueA + valueB\n}\n\nconsole.log(sum(...arr))\n")),(0,o.kt)("p",null,"This program is now valid. What is essentially happening is we have told Typescript to not bother with finding a general type for ",(0,o.kt)("inlineCode",{parentName:"p"},"arr"),". We don't ",(0,o.kt)("em",{parentName:"p"},"want")," general. We want ",(0,o.kt)("em",{parentName:"p"},"exact"),". We want a ",(0,o.kt)("em",{parentName:"p"},"narrow type"),". It's essentially equivalent to writing:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const arr: readonly [number, number] = [1, 2];\n\nconst sum = (valueA: number, valueB: number) => {\n  return valueA + valueB\n}\n\nconsole.log(sum(...arr))\n")),(0,o.kt)("p",null,"Our program works because we have told the compiler that ",(0,o.kt)("inlineCode",{parentName:"p"},"arr")," is always going to be a tuple of two numbers that is not going to change. It can happily spread these two numbers and use them safe in the knowledge that there are two of them, and our function\nwill be satisfied with all the arguments it needs to complete."),(0,o.kt)("p",null,"There is a cool use case for this in the wild: an alternative to ",(0,o.kt)("inlineCode",{parentName:"p"},"enum")," where the keys of an ",(0,o.kt)("inlineCode",{parentName:"p"},"as const")," array can be used in further type definitions. Considering that items in a readonly tuple can be indexed by number reliably, you can use ",(0,o.kt)("inlineCode",{parentName:"p"},"typeof arr[number]")," to represent\nthe type for items contained in your ",(0,o.kt)("inlineCode",{parentName:"p"},"as const")," array."),(0,o.kt)("p",null,"This can be extremely powerful when working with a utility such as ",(0,o.kt)("em",{parentName:"p"},"lodash")," on a task such as stripping data from an object returned from an typed API call, where you know the kinds of keys on the returned object and you need to get the compiler to understand them too:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const { pick } = require("lodash");\n\nconst myObject = {\n  a: 1,\n  b: 2,\n  c: 3,\n  d: 4,\n  e: 5\n};\n\nconst keys = ["a", "b", "c"] as const;\n\nconst stripData = (object: Record<string, number>): Record<typeof keys[number], number> => {\n  return pick(object, ...keys)\n}\n\nconst stripped = stripData(myObject);\n')),(0,o.kt)("p",null,"We can use an ",(0,o.kt)("inlineCode",{parentName:"p"},"as const")," array to define our keys, and use these values to strip unecessary ones from our bloated object. And because we can use the idnexed value from our ",(0,o.kt)("inlineCode",{parentName:"p"},"as const")," array as types as ",(0,o.kt)("em",{parentName:"p"},"well as")," values, we can define a strong return type\nbased on these values with a ",(0,o.kt)("inlineCode",{parentName:"p"},"Record"),". Typescript now knows that ",(0,o.kt)("inlineCode",{parentName:"p"},"stripped")," is an object of type ",(0,o.kt)("inlineCode",{parentName:"p"},"{a: number, b: number, c: number}"),"."),(0,o.kt)("p",null,"Good to know!"))}h.isMDXComponent=!0}}]);